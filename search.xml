<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Boot项目单点登录（SSO）实现与最佳实践</title>
      <link href="/2025/07/18/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95SSO%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/07/18/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95SSO%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-项目单点登录（SSO）实现与最佳实践"><a href="#Spring-Boot-项目单点登录（SSO）实现与最佳实践" class="headerlink" title="Spring Boot 项目单点登录（SSO）实现与最佳实践"></a>Spring Boot 项目单点登录（SSO）实现与最佳实践</h1><h2 id="一、背景与目标"><a href="#一、背景与目标" class="headerlink" title="一、背景与目标"></a>一、背景与目标</h2><p>在现代 Web 系统中，单点登录（SSO, Single Sign-On）是提升用户体验和安全性的关键能力。本文以实际 Spring Boot+前后端分离项目为例，介绍如何实现基于 Cookie+Token 的 SSO，支持 PC、移动端、WebView 等多端无缝集成。</p><h2 id="二、方案原理"><a href="#二、方案原理" class="headerlink" title="二、方案原理"></a>二、方案原理</h2><ul><li><strong>Token 生成与存储</strong>：用户登录成功后，后端生成唯一 Token（如 UUID），写入数据库<code>user_token</code>表，并通过<code>Set-Cookie</code>下发到前端。</li><li><strong>Cookie 自动携带</strong>：前端所有请求都加<code>withCredentials: true</code>，浏览器自动带上<code>auth_token</code>，无需前端手动管理。</li><li><strong>Token 校验与续期</strong>：后端拦截器统一校验 Token，自动续期，保证活跃用户不会被踢下线。</li><li><strong>单点登录</strong>：同一账号同一时间只有一个有效 Token，新登录会踢掉旧会话。</li></ul><h2 id="三、数据库表结构"><a href="#三、数据库表结构" class="headerlink" title="三、数据库表结构"></a>三、数据库表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `user_token` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    `token` <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;登录Token&#x27;</span>,</span><br><span class="line">    `expire_time` DATETIME <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;过期时间&#x27;</span>,</span><br><span class="line">    `create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_token_user` <span class="keyword">FOREIGN KEY</span> (`user_id`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span> <span class="string">&#x27;用户Token表&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>每次登录生成新 Token，写入该表，保证单点登录。</li><li>过期时间支持 Token 续期。</li></ul><h2 id="四、关键后端实现"><a href="#四、关键后端实现" class="headerlink" title="四、关键后端实现"></a>四、关键后端实现</h2><h3 id="1-Token-生成与下发"><a href="#1-Token-生成与下发" class="headerlink" title="1. Token 生成与下发"></a>1. Token 生成与下发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserToken</span> <span class="variable">token</span> <span class="operator">=</span> userTokenService.generateToken(loginUser.getId(), <span class="number">30</span>);</span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;auth_token&quot;</span>, token.getToken());</span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">cookie.setHttpOnly(<span class="literal">true</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>); <span class="comment">// 30天</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><h3 id="2-Token-拦截器与续期机制"><a href="#2-Token-拦截器与续期机制" class="headerlink" title="2. Token 拦截器与续期机制"></a>2. Token 拦截器与续期机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> ... <span class="comment">// 从Cookie中获取auth_token</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span> || !userTokenService.isTokenValid(token)) &#123;</span><br><span class="line">        response.setStatus(<span class="number">401</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;未登录或登录已过期&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自动续期：如果剩余时间不足3天，自动延长30天</span></span><br><span class="line">    <span class="type">UserToken</span> <span class="variable">ut</span> <span class="operator">=</span> userTokenService.getByToken(token);</span><br><span class="line">    <span class="type">long</span> <span class="variable">remain</span> <span class="operator">=</span> ut.getExpireTime().getTime() - System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">3L</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">        userTokenService.refreshToken(token, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;auth_token&quot;</span>, token);</span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="literal">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-CORS-配置"><a href="#3-CORS-配置" class="headerlink" title="3. CORS 配置"></a>3. CORS 配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">    .allowedOrigins(<span class="string">&quot;http://localhost:5173&quot;</span>)</span><br><span class="line">    .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">    .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">    .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="五、前端对接要点与常见坑"><a href="#五、前端对接要点与常见坑" class="headerlink" title="五、前端对接要点与常见坑"></a>五、前端对接要点与常见坑</h2><ul><li>全局设置<code>axios.defaults.withCredentials = true;</code></li><li><strong>所有请求都要加</strong><code>withCredentials: true</code>，否则不会自动带上<code>auth_token</code>。</li><li>CORS 响应头<code>Access-Control-Allow-Origin</code>必须是具体前端地址，不能是<code>*</code>。</li><li>登录后用 F12 检查 Cookie，确认<code>auth_token</code>已保存。</li><li>多端/多标签页/iframe 天然支持 SSO。</li><li><strong>常见坑</strong>：<ul><li>CORS 配置为<code>*</code>时，浏览器不会带 Cookie，后端永远判定未登录。</li><li>代理配置不对，导致请求未转发到后端。</li><li>Cookie 路径、域名设置不一致。</li></ul></li></ul><h2 id="六、生产环境安全建议"><a href="#六、生产环境安全建议" class="headerlink" title="六、生产环境安全建议"></a>六、生产环境安全建议</h2><ul><li>Cookie 建议加<code>Secure</code>属性，仅 HTTPS 下传输。</li><li>设置<code>SameSite=Lax</code>或<code>SameSite=Strict</code>，防止 CSRF 攻击。</li><li>Token 建议用高强度 UUID 或 JWT，防止伪造。</li><li>Token 过期后自动登出，防止长期失效。</li><li>后端接口敏感操作需二次校验（如密码修改、资金操作等）。</li></ul><h2 id="七、接口文档引用"><a href="#七、接口文档引用" class="headerlink" title="七、接口文档引用"></a>七、接口文档引用</h2><p>详见项目内<code>doc/用户接口-前后端对接文档.md</code>，包含登录、登出、Token 续期、系统管理员检测等接口说明。</p><h2 id="八、常见异常案例与排查"><a href="#八、常见异常案例与排查" class="headerlink" title="八、常见异常案例与排查"></a>八、常见异常案例与排查</h2><ul><li><strong>接口返回 401 未登录</strong>：<ul><li>检查 CORS 响应头，是否为具体前端地址。</li><li>检查请求是否带<code>auth_token</code>。</li><li>检查 Token 是否已过期或被顶下线。</li></ul></li><li><strong>接口返回乱码或<code>?????????</code></strong>：<ul><li>检查拦截器是否拦截了无需登录的接口。</li><li>检查响应编码是否为 UTF-8。</li></ul></li><li><strong>Token 未续期</strong>：<ul><li>检查拦截器是否有自动续期逻辑。</li></ul></li></ul><h2 id="九、最佳实践建议"><a href="#九、最佳实践建议" class="headerlink" title="九、最佳实践建议"></a>九、最佳实践建议</h2><ul><li>后端 Token 拦截器统一校验，接口 Controller 无需关心登录态细节。</li><li>CORS 配置必须严格，不能用<code>*</code>，要用具体前端地址。</li><li>Token 存储建议用数据库，便于单点登录和会话管理。</li><li>前端只需全局加<code>withCredentials: true</code>，无需手动存取 Token。</li><li>退出登录时，后端删除 Token 并清除 Cookie。</li><li>支持 Token 自动续期，提升用户体验。</li><li>系统管理员相关接口应放行，无需登录即可初始化。</li></ul><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>基于 Cookie+Token 的 SSO 方案，兼顾了安全性、易用性和多端无缝集成。只要后端 CORS 和 Token 机制配置正确，前端开发几乎“零感知”，极大提升了系统的可维护性和用户体验。</p><p>如有更多 SSO、权限、跨域等实战问题，欢迎留言交流！</p>]]></content>
      
      
      <categories>
          
          <category> 技术实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
            <tag> 单点登录 </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter3.32.6 windows开发环境配置</title>
      <link href="/2025/07/13/flutter3.32.6_windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/07/13/flutter3.32.6_windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-下载需要的软件包"><a href="#1-下载需要的软件包" class="headerlink" title="1. 下载需要的软件包"></a>1. 下载需要的软件包</h3><p>下载flutter </p><p><img src="/images/flutter环境配置/flutter下载包.png" alt="flutter下载包.png"></p><p>下载jdk（最好下载独立程序包）</p><p><img src="/images/flutter环境配置/jdk下载包.png" alt="jdk下载包.png"></p><p>下载vscode  或  Android Studio （路径和用户名非中文）</p><p><img src="/images/flutter环境配置/vscode.png" alt="vscode.png"></p><p>下载插件</p><p><img src="/images/flutter环境配置/flutter插件.png" alt="flutter插件.png"></p><h3 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h3><p>flutter环境下载国内镜像配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setx PUB_HOSTED_URL <span class="string">&quot;https://pub.flutter-io.cn&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setx FLUTTER_STORAGE_BASE_URL <span class="string">&quot;https://storage.flutter-io.cn&quot;</span></span><br></pre></td></tr></table></figure><p>jdk配置</p><p>新建环境变量，变量名为JAVA_HOME，值为刚刚JDK的安装目录  ，再新建一个CLASSPATH，值为%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar<br><img src="/images/flutter环境配置/JAVA_HOME配置.png" alt="JAVA_HOME配置.png"><br><img src="/images/flutter环境配置/CLASSPATH配置.png" alt="CLASSPATH配置.png"><br>配置系统java环境，点击Path，分别新增加%JAVA_HOME%\bin 和 %JAVA_HOME%\jre\bin<br><img src="/images/flutter环境配置/java环境配置.png" alt="java环境配置.png"></p><p>编程工具配置，以vscode为例</p><p>按下 Ctrl + ALT + P 在框内输入 flutter new project  会提示导入flutter。导入之前下载的flutter即可。注意路径不要含中文。因为刚刚设置了PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL国内镜像源。项目初始化速度会挺快的。<br><img src="/images/flutter环境配置/flutter初始化项目目录.png" alt="flutter初始化项目目录.png"></p><h3 id="3-maven和gradle下载镜像配置"><a href="#3-maven和gradle下载镜像配置" class="headerlink" title="3. maven和gradle下载镜像配置"></a>3. maven和gradle下载镜像配置</h3><p><img src="/images/flutter环境配置/镜像路径配置目录.png" alt="镜像路径配置目录.png"><br>settings.gradle文件配置，也可能叫settings.gradle.kts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    val flutterSdkPath = run &#123;</span><br><span class="line">        val properties = java.util.Properties()</span><br><span class="line">        file(&quot;local.properties&quot;).inputStream().use &#123; properties.load(it) &#125;</span><br><span class="line">        val flutterSdkPath = properties.getProperty(&quot;flutter.sdk&quot;)</span><br><span class="line">        require(flutterSdkPath != null) &#123; &quot;flutter.sdk not set in local.properties&quot; &#125;</span><br><span class="line">        flutterSdkPath</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    includeBuild(&quot;$flutterSdkPath/packages/flutter_tools/gradle&quot;)</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://jitpack.io&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/google&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/public&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/center&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/releases&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;dev.flutter.flutter-plugin-loader&quot;) version &quot;1.0.0&quot;</span><br><span class="line">    id(&quot;com.android.application&quot;) version &quot;8.7.3&quot; apply false</span><br><span class="line">    id(&quot;org.jetbrains.kotlin.android&quot;) version &quot;2.1.0&quot; apply false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">include(&quot;:app&quot;)</span><br></pre></td></tr></table></figure><p>build.gradle文件配置，也可能叫build.gradle.kts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://jitpack.io&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/google&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/public&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/center&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(&quot;https://maven.aliyun.com/repository/releases&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val newBuildDir: Directory = rootProject.layout.buildDirectory.dir(&quot;../../build&quot;).get()</span><br><span class="line">rootProject.layout.buildDirectory.value(newBuildDir)</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)</span><br><span class="line">    project.layout.buildDirectory.value(newSubprojectBuildDir)</span><br><span class="line">&#125;</span><br><span class="line">subprojects &#123;</span><br><span class="line">    project.evaluationDependsOn(&quot;:app&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.register&lt;Delete&gt;(&quot;clean&quot;) &#123;</span><br><span class="line">    delete(rootProject.layout.buildDirectory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gradle-wrapper.properties文件配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://mirrors.aliyun.com/gradle/distributions/v8.10.2/gradle-8.10.2-all.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-后续出现的问题"><a href="#4-后续出现的问题" class="headerlink" title="4. 后续出现的问题"></a>4. 后续出现的问题</h3><p>还是出现一直卡在 </p><blockquote><p>Running Gradle task ‘assembleDebug’…</p></blockquote><p>需要在项目的android终端目录下执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean   //可能出现网络卡顿，多运行几次，没问题再运行下面的build</span><br><span class="line"></span><br><span class="line">./gradlew build</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON数据生成工具介绍与技术原理</title>
      <link href="/2025/07/09/json%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2025/07/09/json%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON-数据生成工具：简介与技术实现"><a href="#JSON-数据生成工具：简介与技术实现" class="headerlink" title="JSON 数据生成工具：简介与技术实现"></a>JSON 数据生成工具：简介与技术实现</h1><h2 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h2><p><strong>JSON 数据生成工具</strong>是一款面向开发者、测试工程师和数据分析师的桌面应用，支持通过自定义字段模板，批量生成结构化 JSON 测试数据。该工具具备字段类型丰富、配置灵活、模板管理、批量导出等特性，极大提升测试与开发效率。</p><hr><h2 id="主要功能与实现细节"><a href="#主要功能与实现细节" class="headerlink" title="主要功能与实现细节"></a>主要功能与实现细节</h2><h3 id="1-字段配置与模板管理"><a href="#1-字段配置与模板管理" class="headerlink" title="1. 字段配置与模板管理"></a>1. 字段配置与模板管理</h3><ul><li><p><strong>功能说明</strong>：<br>支持添加、编辑、删除多种类型字段（如姓名、公司、地区、数字、日期、枚举等），每个字段可独立配置属性（如长度、范围、格式等），并可通过拖拽排序。字段配置可保存为模板，方便复用和团队共享。</p></li><li><p><strong>核心实现代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字段拖拽排序</span></span><br><span class="line"><span class="comment"># utils/drag_sort_helper.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enable_listwidget_drag_sort</span>(<span class="params">listwidget, data_list, text_func</span>):</span><br><span class="line">    listwidget.setDragDropMode(QAbstractItemView.InternalMove)</span><br><span class="line">    <span class="comment"># 省略具体同步逻辑</span></span><br></pre></td></tr></table></figure></li><li><p><strong>界面示意</strong>：<br>下图展示了字段配置区，包括字段类型选择、属性设置和拖拽排序功能。<br><img src="/images/Json数据生成工具/字段配置与字段管理.png" alt="字段配置与字段管理.png"></p></li></ul><hr><h3 id="2-批量数据生成与导出"><a href="#2-批量数据生成与导出" class="headerlink" title="2. 批量数据生成与导出"></a>2. 批量数据生成与导出</h3><ul><li><p><strong>功能说明</strong>：<br>用户可指定生成数据条数（如 1~10000 条），一键生成批量 JSON 数据。支持数据预览、复制到剪贴板、导出为 .json 文件，便于快速对接测试。</p></li><li><p><strong>核心实现代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量生成数据</span></span><br><span class="line"><span class="comment"># ui/main_window.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_json</span>(<span class="params">self</span>):</span><br><span class="line">    count = <span class="variable language_">self</span>.count_spin.value()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.fields:</span><br><span class="line">        QMessageBox.warning(<span class="variable language_">self</span>, <span class="string">&quot;提示&quot;</span>, <span class="string">&quot;请先添加字段！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        item = generate_item(<span class="variable language_">self</span>.fields)</span><br><span class="line">        result.append(item)</span><br><span class="line">    <span class="variable language_">self</span>.result_edit.setPlainText(json.dumps(result, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p><strong>界面示意</strong>：<br>见下图，生成区包含生成按钮、条数设置和数据预览区。<br><img src="assets/img/generate_area.png" alt="生成区：生成按钮、条数设置、数据预览区"></p></li></ul><hr><h3 id="3-用户体验优化"><a href="#3-用户体验优化" class="headerlink" title="3. 用户体验优化"></a>3. 用户体验优化</h3><ul><li><p><strong>功能说明</strong>：<br>所有输入框、数字框默认无右键菜单，防止误操作。支持自定义右键菜单（如清空、重置、设为最大/最小值等），界面风格自动跟随系统主题，支持深色/高亮模式。字段配置错误有醒目提示，防止生成无效数据。</p></li><li><p><strong>核心实现代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义无右键菜单数字框</span></span><br><span class="line"><span class="keyword">from</span> components.no_context_menu_widgets <span class="keyword">import</span> NoContextMenuSpinBox</span><br><span class="line">spin = NoContextMenuSpinBox(menu_type=<span class="string">&quot;all&quot;</span>, default_value=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 右键菜单包含：清空、重置为默认值、设为最小值、设为最大值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>界面示意</strong>：<br>下图为主界面深色/高亮主题自适应效果。<br><img src="assets/img/dark_light_theme.png" alt="主界面深色/高亮主题自适应效果"></p></li></ul><hr><h3 id="4-组件化与可扩展性"><a href="#4-组件化与可扩展性" class="headerlink" title="4. 组件化与可扩展性"></a>4. 组件化与可扩展性</h3><ul><li><p><strong>功能说明</strong>：<br>所有通用控件（如无右键菜单输入框、数字框）均独立封装，便于项目复用和维护。支持自定义字段类型、生成规则，适合二次开发和业务扩展。</p></li><li><p><strong>核心实现代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字段生成逻辑（简化版）</span></span><br><span class="line"><span class="comment"># utils/data_generator.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_field</span>(<span class="params">field_type</span>):</span><br><span class="line">    <span class="keyword">if</span> field_type == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice(baijiaxing) + random.choice(mingzi)</span><br><span class="line">    <span class="keyword">elif</span> field_type == <span class="string">&#x27;company&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice(company_list)</span><br><span class="line">    <span class="comment"># ... 其他类型</span></span><br></pre></td></tr></table></figure></li><li><p><strong>项目结构示意</strong>：<br>下图为项目结构图，标注主要模块和组件。<br><img src="assets/img/project_structure.png" alt="项目结构图，标注主要模块和组件"></p></li></ul><hr><h2 id="典型使用流程"><a href="#典型使用流程" class="headerlink" title="典型使用流程"></a>典型使用流程</h2><ol><li>选择或新建字段模板，配置所需字段及类型。</li><li>配置字段属性，为每个字段设置类型、名称、生成规则（如长度、范围、枚举值等）。</li><li>拖拽调整字段顺序，保证生成的 JSON 字段顺序符合需求。</li><li>设置生成条数，点击“一键生成”，实时预览生成结果。</li><li>导出或复制数据，便于接口测试、前端开发等场景。</li></ol><ul><li><strong>操作流程图</strong>：<br>下图展示了从模板选择到数据导出的完整流程。<br><img src="assets/img/usage_flow.png" alt="操作流程：从模板选择到数据导出的完整流程"></li></ul><hr><h2 id="技术亮点与适用场景"><a href="#技术亮点与适用场景" class="headerlink" title="技术亮点与适用场景"></a>技术亮点与适用场景</h2><ul><li><strong>高度组件化</strong>：所有控件和生成逻辑均独立封装，便于复用和维护。</li><li><strong>配置驱动</strong>：字段类型、模板、数据字典等均采用 JSON 配置，灵活扩展，支持热更新。</li><li><strong>极致用户体验</strong>：细节优化，主题自适应，右键菜单可定制，交互友好。</li><li><strong>易于二次开发</strong>：结构清晰，适合团队协作和业务扩展。</li></ul><p>本工具适用于前后端接口联调、Mock 数据生成、自动化测试、教学演示、数据可视化等多种场景。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> 数据生成 </tag>
            
            <tag> PySide6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows多功能工具箱——功能亮点与技术实现解析</title>
      <link href="/2025/07/07/%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/"/>
      <url>/2025/07/07/%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-多功能工具箱——功能亮点与技术实现解析"><a href="#Windows-多功能工具箱——功能亮点与技术实现解析" class="headerlink" title="Windows 多功能工具箱——功能亮点与技术实现解析"></a>Windows 多功能工具箱——功能亮点与技术实现解析</h1><blockquote><p>本文介绍了基于 PySide6 开发的 Windows 多功能工具箱的主要功能、界面设计、关键技术点及实现思路，适合桌面开发爱好者和效率工具用户参考。</p></blockquote><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>本工具箱是一款基于 PySide6 框架开发的 Windows 桌面应用，集成了文件管理、图片处理、开发辅助等常用工具，支持自定义扩展，界面风格简洁美观，支持主题切换和个性化配置。</p><p><strong>[此处插入主界面截图]</strong></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><strong>批量重命名、图片处理、文件批量操作、文本处理</strong><br>（部分功能开发中，后续持续完善）</li><li><strong>支持导入 exe/python 脚本</strong>，可自定义参数、图标、分组管理</li><li><strong>主题切换</strong>：支持自动、亮色、暗色三种主题，界面自适应</li><li><strong>设置面板</strong>：可切换主题、配置文件路径、控制工具打开提示</li><li><strong>工具打开提示</strong>：双击工具时弹窗提示，2 秒后自动关闭</li><li><strong>自定义无边框标题栏</strong>：右上角按钮随主题变色，风格统一</li><li><strong>本地配置保存</strong>，支持后续扩展</li></ul><p><strong>[此处插入设置面板截图]</strong></p><h2 id="界面与交互设计"><a href="#界面与交互设计" class="headerlink" title="界面与交互设计"></a>界面与交互设计</h2><ul><li>左侧为工具类别导航，支持高亮显示和分组管理</li><li>右侧为当前类别下的工具卡片区，网格布局，图标+名称直观展示</li><li>单击卡片可查看工具说明，双击卡片可直接启动工具（可设置是否弹窗提示）</li><li>右上角为自定义标题栏，按钮样式随主题自动切换</li></ul><p><strong>[此处插入工具卡片区截图]</strong></p><h2 id="技术实现要点"><a href="#技术实现要点" class="headerlink" title="技术实现要点"></a>技术实现要点</h2><h3 id="1-PySide6-QSS-主题切换"><a href="#1-PySide6-QSS-主题切换" class="headerlink" title="1. PySide6 + QSS 主题切换"></a>1. PySide6 + QSS 主题切换</h3><ul><li>通过 <code>QPalette</code> 和自定义 QSS 实现自动/亮色/暗色主题切换</li><li>标题栏按钮样式通过 <code>setStyleSheet</code> 动态刷新，保证不同主题下的可读性</li></ul><h3 id="2-配置管理与扩展性"><a href="#2-配置管理与扩展性" class="headerlink" title="2. 配置管理与扩展性"></a>2. 配置管理与扩展性</h3><ul><li>工具箱内容通过 <code>config.json</code> 配置，支持热加载和自定义扩展</li><li>工具类别、图标、描述等均可在配置文件中灵活调整</li><li>预留外部工具导入接口，便于后续扩展</li></ul><h3 id="3-设置面板与用户体验"><a href="#3-设置面板与用户体验" class="headerlink" title="3. 设置面板与用户体验"></a>3. 设置面板与用户体验</h3><ul><li>设置面板支持主题切换、配置路径选择、工具提示开关等</li><li>工具打开时弹窗提示采用自定义 QDialog + QTimer 实现自动关闭，提升用户体验</li></ul><p><strong>[此处插入”工具打开提示”弹窗截图]</strong></p><h3 id="4-代码结构与模块化"><a href="#4-代码结构与模块化" class="headerlink" title="4. 代码结构与模块化"></a>4. 代码结构与模块化</h3><ul><li>主界面、工具卡片、设置面板、工具属性弹窗等均为独立模块，便于维护和扩展</li><li>采用信号与槽机制实现界面与逻辑解耦</li></ul><h2 id="部分核心代码示例"><a href="#部分核心代码示例" class="headerlink" title="部分核心代码示例"></a>部分核心代码示例</h2><p><strong>主题切换与按钮样式刷新：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">refresh_titlebar_btn_style</span>(<span class="params">self</span>):</span><br><span class="line">    theme = <span class="built_in">getattr</span>(<span class="variable language_">self</span>, <span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.btn_setting.setStyleSheet(btn_style(theme=theme))</span><br><span class="line">    <span class="variable language_">self</span>.btn_min.setStyleSheet(btn_style(theme=theme))</span><br><span class="line">    <span class="variable language_">self</span>.btn_close.setStyleSheet(btn_style(close=<span class="literal">True</span>, theme=theme))</span><br></pre></td></tr></table></figure><p><strong>自动关闭提示弹窗：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoCloseMessageDialog</span>(<span class="title class_ inherited__">QDialog</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message, timeout=<span class="number">2000</span>, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(parent)</span><br><span class="line">        <span class="variable language_">self</span>.setWindowTitle(<span class="string">&#x27;提示&#x27;</span>)</span><br><span class="line">        <span class="comment"># ...布局省略...</span></span><br><span class="line">        QTimer.singleShot(timeout, <span class="variable language_">self</span>.accept)</span><br></pre></td></tr></table></figure><h2 id="后续展望"><a href="#后续展望" class="headerlink" title="后续展望"></a>后续展望</h2><ul><li>持续完善内置工具功能</li><li>支持更多外部工具导入与参数配置</li><li>多语言切换与更多主题支持</li><li>用户反馈与自动更新机制</li></ul><hr><blockquote><p><strong>[此处插入项目 Logo 或团队合影]</strong></p></blockquote><p>如对本项目感兴趣，欢迎留言交流或参与贡献！</p>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PySide6 </tag>
            
            <tag> 桌面开发 </tag>
            
            <tag> 工具箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程的区分</title>
      <link href="/2025/07/05/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/07/05/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程的区分"><a href="#进程和线程的区分" class="headerlink" title="进程和线程的区分"></a>进程和线程的区分</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程是操作系统资源分配和管理的基本单位，每个进程拥有独立的代码、数据和堆栈空间。</li><li>进程之间相互独立，通常通过操作系统提供的进程间通信（IPC）机制（如管道、消息队列、共享内存、信号量等）进行数据交换。</li><li>进程的创建和销毁开销较大，适合需要高度隔离和安全性的场景。</li><li>进程崩溃不会直接影响其他进程，提高了系统的稳定性。</li><li><p>Python代码示例（多进程）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">child_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;子进程 PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子进程正在执行任务...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parent_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;父进程 PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;父进程正在执行任务...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    process = multiprocessing.Process(target=child_task)</span><br><span class="line">    process.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 父进程执行</span></span><br><span class="line">    parent_task()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待子进程完成</span></span><br><span class="line">    process.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有进程执行完成&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是程序执行的最小单位，是进程内的一个执行流。</li><li>同一进程内的线程共享代码段、数据段和打开的文件等资源，但每个线程有独立的栈空间和寄存器。</li><li>线程之间的切换开销较小，适合需要大量并发操作的场景，如高并发服务器、实时计算等。</li><li>线程之间通信简单，可以直接读写共享内存，但需要注意同步和互斥，防止数据竞争。</li><li>线程崩溃可能影响同一进程内的其他线程，降低了隔离性。</li><li><p>Python代码示例（多线程）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_task</span>(<span class="params">worker_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程 <span class="subst">&#123;worker_id&#125;</span> 开始执行&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟工作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;线程 <span class="subst">&#123;worker_id&#125;</span> 执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    threads = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        thread = threading.Thread(target=worker_task, args=(i,))</span><br><span class="line">        threads.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有线程执行完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他角度对比"><a href="#其他角度对比" class="headerlink" title="其他角度对比"></a>其他角度对比</h2><ul><li><strong>调度</strong>：进程由操作系统内核调度，线程可以由内核或用户级线程库调度。</li><li><strong>资源占用</strong>：进程资源占用较多，线程资源占用较少。</li><li><strong>适用场景</strong>：进程适合需要隔离的任务（如不同应用），线程适合需要高并发的任务（如 Web 服务器）。</li><li><strong>安全性</strong>：进程间更安全，线程间更高效但安全性较低。</li><li><strong>示例应用</strong>：<ul><li>进程：浏览器的不同标签页、操作系统的不同服务。</li><li>线程：Web 服务器的并发请求处理、图像处理中的多线程计算。</li></ul></li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>进程是资源分配的基本单位，而线程是 CPU 调度的基本单位。</li><li>进程之间相互独立，线程之间可以共享数据。</li><li>创建和销毁进程的开销大于线程。</li><li>进程切换的开销大于线程切换，因为进程切换需要保存和恢复更多的状态信息。</li><li>进程间通信（IPC）通常比线程间通信更复杂和耗时</li><li>线程可以更高效地利用多核处理器，因为它们可以在同一进程内并发执行。</li><li>进程通常用于实现应用程序的隔离和安全性，而线程用于实现并发和并行处理。</li><li>进程可以有多个线程，但线程不能独立于进程存在。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
